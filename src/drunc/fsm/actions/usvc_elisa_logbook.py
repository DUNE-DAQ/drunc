from drunc.fsm.core import FSMAction
import requests
import os
import json

class ElisaLogbook(FSMAction):
    def __init__(self, configuration):
        super().__init__(name = "elisa-logbook")

        from drunc.utils.utils import expand_path
        f = open(expand_path("~/.drunc.json"))
        dotdrunc = json.load(f)
        self.API_SOCKET = dotdrunc["elisa_configuration"]["socket"]
        self.API_USER =  dotdrunc["elisa_configuration"]["user"]
        self.API_PASS =  dotdrunc["elisa_configuration"]["password"]
        self.timeout = 5

        import logging
        self._log = logging.getLogger('microservice')

    def post_start(self, _input_data:dict, _context, message:str="")
        text = ''
        if message != '':
            self.log.info(f"Adding the message:\n--------\n{message}\n--------\nto the logbook")
            text += f"\n<p>{message}</p>"

        run_type = _input_data.get('run_type', "TEST")    #This class won't exist in a test run, so we're adding this temporarily so that we can actually run the function

        #This is equivalent code from nanorc, doing this in drunc will need to wait until the config structure is finalised.
        '''
        run_configuration = find_configuration(_context.configuration.initial_data)
        config_pretty = f'Configuration: {run_config}\n<ul>'

        for k, v in self.cfg.top_cfg.items():
            if k == "apparatus_id": continue

            config_pretty += f'<li>{k}: {v.path}</li>'

        config_pretty += '</ul>'

        text += f"\n<p>{config_pretty]</p>"
        '''

        if message != '' and self.current_run_type.lower() != 'prod':
            self.log.warning('Your message will NOT be stored, as this is not a PROD run')

        for message in messages:
            text += f"\n<p>{message}</p>"
        text += "\n<p>log automatically generated by NanoRC.</p>"
        title = f"Run {_input_data['run']} ({run_type}) started on {_input_data['det_id']}"

        data = {'author':_context.actor.get_user_name(), 'title':title, 'body':text, 'command':start, 'systems':['DAQ']}
        print(data)
        #r = requests.post(f'{self.API_SOCKET}/v1/elisaLogbook/new_message', auth=(self.API_USER,self.API_PASS), data=data)

     def post_drain_dataflow(self, _input_data, _context, message:str="", **kwargs):

from drunc.fsm.core import FSMAction
from drunc.utils.configuration import find_configuration
import json
import os
import requests

class ElisaLogbook(FSMAction):
    def __init__(self, configuration):
        super().__init__(name = "elisa-logbook")

        from drunc.utils.utils import expand_path
        f = open(expand_path("~/.drunc.json"))
        dotdrunc = json.load(f)
        self.API_SOCKET = dotdrunc["elisa_configuration"]["socket"]
        self.API_USER =  dotdrunc["elisa_configuration"]["user"]
        self.API_PASS =  dotdrunc["elisa_configuration"]["password"]
        self.timeout = 5

        import logging
        self._log = logging.getLogger('microservice')

    def post_start(self, _input_data:dict, _context, elisa_post:str='', **kwargs):
        from drunc.fsm.exceptions import CannotSendElisaMessage
        text = ''
        print(_input_data)
        print(f"dotdrunc data is {dotdrunc["elisa_configuration"]}")
        _input_data['id'] = None    #Clear this value here, so that if it fails stop can't reply to an old message

        if elisa_post != '':
            self._log.info(f"Adding the message:\n--------\n{elisa_post}\n--------\nto the logbook")
            text += f"\n<p>{elisa_post}</p>"

        run_type = _input_data.get('run_type', "TEST")    #This class won't exist in a test run, so we're adding this temporarily so that we can actually run the function
        run_configuration = find_configuration(_context.configuration.initial_data)
        config_pretty = f'Configuration: {run_configuration}\n<ul>'
        text += f"\n<p>{config_pretty}</p>"

        if elisa_post != '' and run_type.lower() != 'prod':
            self._log.warning('Your message will NOT be stored, as this is not a PROD run')

        text += "\n<p>log automatically generated by DRunC.</p>"
        det_id = _context.configuration.db.get_dal(class_name = "Session", uid = _context.configuration.oks_key.session).detector_configuration.id
        title = f"Run {_input_data['run']} ({run_type}) started on {det_id}"

        data = {'author':_context.actor.get_user_name(), 'title':title, 'body':text, 'command':'start', 'systems':['DAQ']}
        try:
            r = requests.post(f'{self.API_SOCKET}/new_message', auth=(self.API_USER,self.API_PASS), data=data)
            response = r.json()
            r.raise_for_status()
            _input_data['id'] = response['id']
        except requests.HTTPError as exc:
            error = f"of HTTP Error (maybe failed auth, maybe ill-formed post message, ...) using {__name__}"
            self._log.warning(CannotSendElisaMessage(error).message)
        except requests.ConnectionError as exc:
            error = f"connection to {self.API_SOCKET} wasn't successful using {__name__}"
            self._log.warning(CannotSendElisaMessage(error).message)
        except requests.Timeout as exc:
            error = f"connection to {self.API_SOCKET} timed out using {__name__}"
            self._log.warning(CannotSendElisaMessage(error).message)

        return _input_data

    def post_drain_dataflow(self, _input_data, _context, elisa_post:str='', **kwargs):
        from drunc.fsm.exceptions import CannotSendElisaMessage
        text = ''
        print(_input_data)
        if elisa_post != '':
            self._log.info(f"Adding the message:\n--------\n{elisa_post}\n--------\nto the logbook")
            text += f"\n<p>{elisa_post}</p>"

        run_type = _input_data.get('run_type', "TEST")

        text += f"Run {self.current_run_num} ({self.current_run_type}) stopped on {session}"
        text += "\n<p>log automatically generated by DRunC.</p>"
        title = "User comment"
        data = {'author':_context.actor.get_user_name(), 'title':title, 'body':text, 'command':'stop', 'systems':['DAQ'], 'id':_input_data['id']}
        try:
            r = requests.put(f'{self.API_SOCKET}/v1/elisaLogbook/reply', auth=(self.API_USER,self.API_PASS), data=data)
            response = r.json()
            r.raise_for_status()
        except requests.HTTPError as exc:
            error = f"of HTTP Error (maybe failed auth, maybe ill-formed post message, ...) using {__name__}"
            self._log.warning(CannotSendElisaMessage(error).message)
        except requests.ConnectionError as exc:
            error = f"connection to {self.API_SOCKET} wasn't successful using {__name__}"
            self._log.warning(CannotSendElisaMessage(error).message)
        except requests.Timeout as exc:
            error = f"connection to {self.API_SOCKET} timed out using {__name__}"
            self._log.warning(CannotSendElisaMessage(error).message)

        return _input_data
